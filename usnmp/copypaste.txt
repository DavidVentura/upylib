f=open('usnmp_codec.py','w')
f.write('SNMP_VER1 = const(0x00)\n')
f.write('ASN1_INT = const(0x02)\n')
f.write('ASN1_OCTSTR = const(0x04)\n')
f.write('ASN1_OID = const(0x06)\n')
f.write('ASN1_NULL = const(0x05)\n')
f.write('ASN1_SEQ = const(0x30)\n')
f.write('SNMP_GETREQUEST = const(0xa0)\n')
f.write('SNMP_GETNEXTREQUEST = const(0xa1)\n')
f.write('SNMP_GETRESPONSE = const(0xa2)\n')
f.write('SNMP_SETREQUEST = const(0xa3)\n')
f.write('SNMP_TRAP = const(0xa4)\n')
f.write('SNMP_COUNTER = const(0x41)\n')
f.write('SNMP_GUAGE = const(0x42)\n')
f.write('SNMP_TIMETICKS = const(0x43)\n')
f.write('SNMP_IPADDR = const(0x40)\n')
f.write('SNMP_OPAQUE = const(0x44)\n')
f.write('SNMP_NSAPADDR = const(0x45)\n')
f.write('SNMP_ERR_NOERROR = const(0x00)\n')
f.write('SNMP_ERR_TOOBIG = const(0x01)\n')
f.write('SNMP_ERR_NOSUCHNAME = const(0x02)\n')
f.write('SNMP_ERR_BADVALUE = const(0x03)\n')
f.write('SNMP_ERR_READONLY = const(0x04)\n')
f.write('SNMP_ERR_GENERR = const(0x05)\n')
f.write('SNMP_TRAP_COLDSTART = const(0x0)\n')
f.write('SNMP_TRAP_WARMSTART = const(0x10)\n')
f.write('SNMP_TRAP_LINKDOWN = const(0x2)\n')
f.write('SNMP_TRAP_LINKUP = const(0x3)\n')
f.write('SNMP_TRAP_AUTHFAIL = const(0x4)\n')
f.write('SNMP_TRAP_EGPNEIGHLOSS = const(0x5)\n')
f.write('\n')
f.write('#ASN.1 sequence and SNMP derivatives\n')
f.write('_SNMP_SEQs = bytes([ASN1_SEQ,\n')
f.write('                    SNMP_GETREQUEST,\n')
f.write('                    SNMP_GETRESPONSE,\n')
f.write('                    SNMP_GETNEXTREQUEST,\n')
f.write('                    SNMP_SETREQUEST,\n')
f.write('                    SNMP_TRAP\n')
f.write('                  ])\n')
f.write('\n')
f.write('#ASN.1 int and SNMP derivatives\n')
f.write('_SNMP_INTs = bytes([ASN1_INT,\n')
f.write('                    SNMP_COUNTER,\n')
f.write('                    SNMP_GUAGE,\n')
f.write('                    SNMP_TIMETICKS\n')
f.write('                  ])\n')
f.write('\n')
f.write('\n')
f.write('def tobytes_tv(t, v=None):\n')
f.write('    if t in _SNMP_SEQs:\n')
f.write('        b = v\n')
f.write('    elif t == ASN1_OCTSTR:\n')
f.write('        if type(v) is str:\n')
f.write('            b = bytes(v,"utf-8")\n')
f.write('        elif type(v) in (bytes, bytearray):\n')
f.write('            b = v\n')
f.write('        else:\n')
f.write('            raise ValueError("string or buffer required")\n')
f.write('    elif t in _SNMP_INTs:\n')
f.write('        if v < 0:\n')
f.write('            raise ValueError("ASN.1 ints must be >=0")\n')
f.write('        else:\n')
f.write('            b = bytes() if v!=0 else bytes(1)\n')
f.write('            while v > 0:\n')
f.write('                b = bytes([v & 0xff]) + b\n')
f.write('                v //= 0x100\n')
f.write('            if len(b)>0 and b[0]&0x80 == 0x80:\n')
f.write('                b = bytes([0x0]) + b\n')
f.write('    elif t == ASN1_NULL:\n')
f.write('        b = bytes()\n')
f.write('    elif t == ASN1_OID:\n')
f.write('        oid = v.split(".")\n')
f.write('        #first two indexes are encoded in single byte\n')
f.write('        b = bytes([int(oid[0])*40 + int(oid[1])])\n')
f.write('        for id in oid[2:]:\n')
f.write('            id = int(id)\n')
f.write('            ob = bytes() if id>0 else bytes([0])\n')
f.write('            while id > 0:\n')
f.write('                ob = bytes([id&0x7f if len(ob)==0 else 0x80+(id&0x7f)]) + ob\n')
f.write('                id //= 0x80\n')
f.write('            b += ob\n')
f.write('    elif t == SNMP_IPADDR:\n')
f.write('        b = bytes()\n')
f.write('        for octet in v.split("."):\n')
f.write('            octet = int(octet)\n')
f.write('            b = b + bytes([octet])\n')
f.write('    elif t in (SNMP_OPAQUE, SNMP_NSAPADDR):\n')
f.write('        raise Exception("not implemented", t)\n')
f.write('    else:\n')
f.write('        raise TypeError("invalid type", t)\n')
f.write('    return bytes([t]) + tobytes_len(len(b)) + b\n')
f.write('\n')
f.write('def tobytes_len(l):\n')
f.write('    if l < 0x80:\n')
f.write('        return bytes([l])\n')
f.write('    else:\n')
f.write('        b = bytes()\n')
f.write('        while l>0:\n')
f.write('            b = bytes([l&0xff]) + b\n')
f.write('            l //= 0x100\n')
f.write('        return bytes([0x80+len(b)]) + b\n')
f.write('\n')
f.write('def frombytes_tvat(b, ptr):\n')
f.write('    t = b[ptr]\n')
f.write('    l, l_incr = frombytes_lenat(b, ptr)\n')
f.write('    end = ptr+1+l+l_incr\n')
f.write('    ptr +=  1+l_incr\n')
f.write('    if t in _SNMP_SEQs:\n')
f.write('        v = bytes(b[ptr:end])\n')
f.write('    elif t == ASN1_OCTSTR:\n')
f.write('        try:\n')
f.write('            v = str(b[ptr:end], "utf-8")\n')
f.write('        except: #UnicodeDecodeError:\n')
f.write('            v = bytes(b[ptr:end])\n')
f.write('    elif t in _SNMP_INTs:\n')
f.write('        v=0\n')
f.write('        while ptr < end:\n')
f.write('            v = v*0x100 + b[ptr]\n')
f.write('            ptr += 1\n')
f.write('    elif t == ASN1_NULL:\n')
f.write('        v=None\n')
f.write('    elif t == ASN1_OID:\n')
f.write('        #first 2 indexes are encoded in single byte\n')
f.write('        v = str( b[ptr]//0x28 ) + "." + str( b[ptr]%0x28 )\n')
f.write('        ptr += 1\n')
f.write('        ob = 0\n')
f.write('        while ptr < end:\n')
f.write('            if b[ptr]&0x80 == 0x80:\n')
f.write('                ob = ob*0x80 + (b[ptr]&0x7f)\n')
f.write('            else:\n')
f.write('                v += "." + str((ob*0x80)+b[ptr])\n')
f.write('                ob = 0\n')
f.write('            ptr += 1\n')
f.write('    elif t == SNMP_IPADDR:\n')
f.write('        v = ""\n')
f.write('        while ptr < end:\n')
f.write('            v += "." + str(b[ptr]) if v!="" else str(b[ptr])\n')
f.write('            ptr += 1\n')
f.write('    elif t in (SNMP_OPAQUE, SNMP_NSAPADDR):\n')
f.write('        raise Exception("not implemented", t)\n')
f.write('    else:\n')
f.write('        raise TypeError("invalid type", t)\n')
f.write('    return t, v\n')
f.write('\n')
f.write('def frombytes_lenat(b, ptr):\n')
f.write('    if b[ptr+1]&0x80 == 0x80:\n')
f.write('        l = 0\n')
f.write('        for i in b[ptr+2 : ptr+2+b[ptr+1]&0x7f]:\n')
f.write('            l = l*0x100 + i\n')
f.write('        return l, 1 + b[ptr+1]&0x7f\n')
f.write('    else:\n')
f.write('        return b[ptr+1], 1\n')
f.close()
f=open('usnmp.py','w')
f.write('from usnmp_codec import *\n')
f.write('\n')
f.write('_SNMP_PROPS = ("ver", "community")\n')
f.write('_SNMP_TRAP_PROPS = ("enterprise", "agent_addr", "generic_trap", "specific_trap", "timestamp")\n')
f.write('_SNMP_GETSET_PROPS = ("id", "err_status", "err_id")\n')
f.write('#packet templates, refer template.py\n')
f.write('_SNMP_GETSET_TEMPL = b"0\x14\x02\x00\x04\x06public\xa0\x08\x02\x00\x02\x00\x02\x000\x00"\n')
f.write('_SNMP_TRAP_TEMPL = b"0%\x02\x01\x00\x04\x06public\xa4\x18\x06\x05+\x06\x01\x04\x01@\x04\x7f\x00\x00\x01\x02\x01\x00\x02\x01\x00C\x01\x000\x00"\n')
f.write('\n')
f.write('\n')
f.write('class SnmpPacket:\n')
f.write('\n')
f.write('    def __init__(self, *args, **kwargs):\n')
f.write('        if len(args) == 1 and type(args[0]) in (bytes, bytearray, memoryview):\n')
f.write('            b = args[0]\n')
f.write('        elif "type" in kwargs:\n')
f.write('            if kwargs["type"]== SNMP_TRAP:\n')
f.write('                b = _SNMP_TRAP_TEMPL\n')
f.write('            else:\n')
f.write('                b = _SNMP_GETSET_TEMPL\n')
f.write('        else:\n')
f.write('            raise ValueError("buffer or type=x required")\n')
f.write('        ptr = 1 + frombytes_lenat(b, 0)[1]\n')
f.write('        ptr = self._frombytes_props(b, ptr, _SNMP_PROPS)\n')
f.write('        self.type = b[ptr]\n')
f.write('        ptr += 1 + frombytes_lenat(b, ptr)[1] #step into seq\n')
f.write('        if self.type == SNMP_TRAP:\n')
f.write('            ptr = self._frombytes_props(b, ptr, _SNMP_TRAP_PROPS)\n')
f.write('        else:\n')
f.write('            ptr = self._frombytes_props(b, ptr, _SNMP_GETSET_PROPS)\n')
f.write('        ptr += 1 + frombytes_lenat(b, ptr)[1]\n')
f.write('        ##reinstate when esp support OrderedDict\n')
f.write('        #self.varbinds = OrderedDict()\n')
f.write('        self.varbinds = {}\n')
f.write('        while ptr < len(b):\n')
f.write('            ptr += 1 + frombytes_lenat(b, ptr)[1] #step into seq\n')
f.write('            oid = frombytes_tvat(b, ptr)[1]\n')
f.write('            ptr += 1 + sum(frombytes_lenat(b, ptr))\n')
f.write('            tv = frombytes_tvat(b, ptr)\n')
f.write('            ptr += 1 + sum(frombytes_lenat(b, ptr))\n')
f.write('            self.varbinds[oid] = tv\n')
f.write('        for arg in kwargs:\n')
f.write('            if hasattr(self, arg):\n')
f.write('                setattr(self, arg, kwargs[arg])\n')
f.write('\n')
f.write('    def tobytes(self):\n')
f.write('        b = bytes()\n')
f.write('        for oid in self.varbinds:\n')
f.write('            if self.varbinds[oid] == None:\n')
f.write('                t,v = ASN1_NULL, None\n')
f.write('            else:\n')
f.write('                t,v = self.varbinds[oid]\n')
f.write('            b += tobytes_tv(ASN1_SEQ, tobytes_tv(ASN1_OID, oid) + tobytes_tv(t,v))\n')
f.write('        b = tobytes_tv(ASN1_SEQ, b)\n')
f.write('        if self.type == SNMP_TRAP:\n')
f.write('            b = tobytes_tv(ASN1_OID, self.enterprise) \\\n')
f.write('                + tobytes_tv(SNMP_IPADDR, self.agent_addr) \\\n')
f.write('                + tobytes_tv(ASN1_INT, self.generic_trap) \\\n')
f.write('                + tobytes_tv(ASN1_INT, self.specific_trap) \\\n')
f.write('                + tobytes_tv(SNMP_TIMETICKS, self.timestamp) \\\n')
f.write('                + b\n')
f.write('        else:\n')
f.write('            b = tobytes_tv(ASN1_INT, self.id) \\\n')
f.write('                + tobytes_tv(ASN1_INT, self.err_status) \\\n')
f.write('                + tobytes_tv(ASN1_INT, self.err_id) \\\n')
f.write('                + b\n')
f.write('        return tobytes_tv(ASN1_SEQ, tobytes_tv(ASN1_INT, self.ver) \\\n')
f.write('                + tobytes_tv(ASN1_OCTSTR, self.community) \\\n')
f.write('                + tobytes_tv(self.type, b))\n')
f.write('\n')
f.write('    def _frombytes_props(self, b, ptr, properties):\n')
f.write('        for prop in properties:\n')
f.write('            setattr(self, prop, frombytes_tvat(b, ptr)[1])\n')
f.write('            ptr += 1 + sum(frombytes_lenat(b, ptr))\n')
f.write('        return ptr\n')
f.close()